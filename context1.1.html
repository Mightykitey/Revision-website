<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="T-Level digital Revision">
    <meta name="keywords" content="Revision, T-level digital, UTC, digital, Kyte, Tyler, Kite">
    <meta name="author" content="Kyte, Tyler">
    <title>Context 1.1 - Computational Thinking</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="shortcut icon" type="image/x-icon" href="logo.jpg" />
</head>
<body>
    <div class="container">
        <h3>1.1.1 - Be able to use top-down, bottom-up, and modularisation approaches to solve problems</h3>
        <p><strong>Top-down:</strong> The top-down approach involves starting with a broad overview of the problem, then breaking it down into smaller, more manageable parts. This hierarchical method of solving problems is effective for tackling complex systems and large projects. It encourages thinking about the big picture first and then zooming in to tackle the smaller components. This approach helps with planning and gives a clear structure for solving large problems incrementally.</p>
        <p><strong>Bottom-up:</strong> In contrast, the bottom-up approach starts by focusing on the smallest components or individual details of a problem, gradually building up to form a complete solution. It’s particularly useful when the solution isn’t clear from the outset, or when developing a system from scratch. It allows for more flexibility and encourages experimenting with smaller parts that you know work, then combining them into a larger structure.</p>
        <p><strong>Modularisation:</strong> Modularisation involves dividing a problem or system into discrete, self-contained modules that can each be independently developed and tested. Each module performs a specific function and can be integrated into the larger system once it is developed. This approach improves efficiency, readability, and scalability of the system by ensuring that changes or updates to one module do not affect others. Additionally, modularisation aids in the reuse of code and reduces complexity during development.</p>

        <h3>1.1.2 - Be able to decompose problems by:</h3>
        <ul>
            <li>Breaking a problem down into smaller, more manageable parts: Decomposition allows for a more systematic approach to problem-solving. By isolating smaller tasks, each can be handled individually, making the problem less overwhelming. Decomposition is essential in reducing complexity in large projects or systems, allowing developers to focus on solving smaller challenges that build up to the final solution.</li>
            <li>Identifying and describing the main features of a problem or process: This helps to create a clear understanding of the problem’s scope and constraints. Once the key components are identified, it becomes easier to focus on critical aspects and align resources accordingly. This approach streamlines problem-solving by keeping the focus on what is truly important.</li>
        </ul>
        <h4>Advantages:</h4>
        <ul>
            <li>The problem can be better understood by breaking it down into simpler parts, which reduces cognitive load and allows for a more focused approach.</li>
            <li>Each sub-problem can be developed and tested separately, improving the overall development process by isolating potential issues early on and enabling easier debugging.</li>
            <li>The overall system becomes more manageable, and the decomposition process allows for clearer steps towards the solution, enhancing overall efficiency.</li>
        </ul>
        <h4>Drawbacks:</h4>
        <ul>
            <li>It is crucial to fully understand the original problem before decomposition; failing to do so could result in parts that do not address the core issue, leading to wasted effort and resources.</li>
            <li>The sub-problems might not provide a fully functional solution on their own, which means additional work may be required to re-integrate them into the overall problem.</li>
        </ul>

        <h3>1.1.3 - Be able to use pattern recognition to:</h3>
        <ul>
            <li>Identify and describe trends and similarities within and between problems and processes: Pattern recognition allows for spotting recurring issues or characteristics across different problems. By recognizing similarities, one can apply previously tested solutions or refine strategies based on historical trends, saving time and resources.</li>
            <li>Identify and describe common features between a given problem and existing solutions: Recognizing similarities between a new challenge and past problems enables the use of established solutions, which may only need slight modifications to address the current problem.</li>
            <li>Make predictions and assumptions based on identified patterns: The ability to predict potential outcomes based on past patterns improves decision-making. It helps anticipate future challenges and prepare solutions or strategies accordingly, making processes more efficient and outcomes more predictable.</li>
        </ul>
        <h4>Advantages:</h4>
        <ul>
            <li>Helps identify recurring problems, which could allow faster identification of solutions from past experiences and reduces the time spent reinventing solutions.</li>
            <li>Allows for efficient problem-solving by recognizing similarities and adapting solutions to new situations, leading to quicker, more effective resolutions.</li>
            <li>Improves prediction and decision-making by identifying trends and patterns that inform actions. This helps optimize processes and avoid potential issues before they arise.</li>
        </ul>
        <h4>Disadvantages:</h4>
        <ul>
            <li>Over-reliance on past solutions may lead to missed opportunities or solutions that are not optimal for the current situation, especially in dynamic or rapidly changing environments.</li>
            <li>Recognizing patterns without careful analysis could lead to assumptions that may not always hold true in every situation, potentially causing errors or misinterpretations.</li>
        </ul>

        <h3>1.1.4 - Be able to use abstraction to:</h3>
        <ul>
            <li>Identify information that is needed to solve an identified problem: Abstraction helps simplify complex problems by focusing only on the relevant information. It reduces noise and streamlines the process by stripping away unnecessary details, allowing for a clearer understanding of the core problem.</li>
            <li>Filter out unnecessary details at different stages of a problem: At different stages of problem-solving, abstraction helps by removing extraneous information that does not contribute to the solution, allowing a more focused and efficient approach.</li>
            <li>Create a layer of abstraction appropriate to the stage in the problem-solving process: As problem-solving progresses, abstraction can be adjusted. In early planning stages, a higher level of abstraction is appropriate, while more detailed layers of abstraction are needed during implementation to ensure clarity and precision in the solution.</li>
        </ul>
        <h4>Key Features:</h4>
        <ul>
            <li>Allows you to focus on essential aspects of a problem, simplifying complex problems into manageable tasks and enabling efficient decision-making.</li>
            <li>Facilitates problem-solving at different levels by removing unnecessary information and honing in on the key details, making the approach more effective.</li>
            <li>Provides flexibility by allowing different levels of abstraction to be applied at various stages of problem-solving, depending on the task at hand. It is a dynamic tool that adapts to the needs of the process.</li>
        </ul>
        <h4>Advantages:</h4>
        <ul>
            <li>Reduces complexity by removing unnecessary details and focusing on what is most important for solving the problem, which helps improve efficiency and accuracy.</li>
            <li>Helps in creating solutions that are flexible and scalable by focusing on generalized patterns and concepts rather than specific details, which allows solutions to be more adaptable in different contexts.</li>
            <li>Improves efficiency by reducing cognitive load and enabling a streamlined approach to problem-solving, thus allowing quicker resolutions with fewer complications.</li>
        </ul>
        <h4>Disadvantages:</h4>
        <ul>
            <li>Over-abstraction can lead to the loss of critical details, which may be important in solving the problem. Striking the right balance between simplicity and necessary complexity is essential.</li>
            <li>Finding the right level of abstraction can be challenging, as too little or too much abstraction can complicate the process and create confusion.</li>
            <li>It may be difficult to apply abstraction when the problem is highly specific or involves unique elements that are hard to generalize. This requires careful consideration to avoid oversimplification.</li>
        </ul>

        <footer>
            <a href="context1.html">Back to Context 1</a> | <a href="index.html">Return to New Website</a>
        </footer>
    </div>
</body>
</html>
